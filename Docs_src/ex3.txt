Practical 3: Object oriented programming
========================================
:Author: Andrew Walker
:Email: andrew.walker@bristol.ac.uk
:Revision: 0.1

We've seen that it's not necessary to know about 
object-oriented (OO) programming to write useful 
tools using Python. However, Python is an OO 
language and knowing something about how 
object-orientation works and is implemented in 
Python will help you understand many features of 
the language. It is sometimes useful to write your 
programs in an OO style. More commonly you will make 
use of a library that provides an OO interface. Knowing 
how to write your own OO interface will help you make 
use of other peoples designs.

In this session you will explore how to make use of 
modules from the standard library that expose OO interfaces.
You will then modify the rainfall analysis code you wrote on 
Tuesday so that each weather station's data is represented by 
an object. This will allow you to produce more complex 
analysis easily without producing excessively complex code. First
we will look at some objects from the standard library

Exercise 1: Random numbers and dates – objets from the outside
--------------------------------------------------------------

It is often useful to be able to generate (pseudo-) random numbers 
for use in numerical programs. These can be used for Monte-Carlo 
simulation or error analysis. Random number generators can be 
modelled as objects. The way numbers are generated are hidden 
in a "black box". Methods are provided to set up (seed) the 
generator and return a random number drawn from some distribution. 

Write a simple Python program to calculate the average of 100 random 
numbers drawn from the range [0.0, 1.0). You will need to import the 
`random` module, create an instance of the `random.Random` class, use 
the instance's `seed()` function to set up the generator, and then use 
the `random()` method to generate each random number. In this case, neither 
the class constructor `random()` or `seed()` need arguments.

[NOTE]
=====
Remember that 
instances of any class look like variables and methods can be called 
by appending a dot and the method name (with arguments in brackets) to 
the instance. That is, a new instance of the class `Thing` is created 
by the code `this_thing = Thing(constructer_argument)`. Methods and
attributes of the instance `this_thing` can then be accessed as
`this_thing.method(method_argument)` and `this_thing.attribute`.
=====

Another class provided by the standard library creates 
`date` objects. This is available from the `datetime` module. 
Unlike the random number class, the `date` class constructor 
accepts arguments, specifically three integers giving the year,
 month and day of the date to be represented. Start up a Python 
interpreter and `import` the datetime module. Create two `date` 
objects, one representing February 3, 1700 and one representing 
October 4, 1701. What is the day of the week of these two dates? 
You can use the `weekday()` method to find out (this returns 0 
for Monday, 1 for Tuesday and 6 for Sunday).  How many days are 
there between the two dates? (Note that arithmetic with date 
objects return a `timedelta` object, these have the attribute 
`days`.) Repeat the exercise for February and October 2000 and 
2001. Is the number of days between the two dates the 
same? If not, why not?

Exercise 2: Compressed data input – using objects for flexibility
-----------------------------------------------------------------

Data files are often compressed and it can be helpful 
if your analysis code can read (and write) to compressed 
files. As well as being convenient (you can avoid explicitly 
compressing or decompressing files before and after you run 
the analysis script) this can also improve execution time 
(this is sometimes limited just by the process of getting 
data to and from the disk). In common with all data types, 
we have seen that Python’s built in file type is a class. 
An instance of this type is returned by the built-in 
`open()` function and each instance supports a range of 
methods including iteration. The standard library includes 
the link:http://docs.python.org/library/gzip.html[module `gzip`]
 which implements the `GzipFile` class with 
methods that simulate most of those provided by the built-in 
file type. There is also a 
link:http://docs.python.org/library/bz2.html[`bz2` module], 
which does a similar 
thing for bzip2 compression. The directory XXX contains the 
same Met Office data you worked with on Tuesday but some files 
have been compressed using either bzip2 or gzip. Modify your 
final data file reading function to automatically accept 
compressed files. You can assume that compressed files will 
always have the .gz or .bz2 file extension.

[NOTE]
===============================
The most obvious OO way to instantiate an object to 
represent a compressed file is to make direct use of the 
GzipFile class as follows:
[code,python]
----
import gzip
f = gzip.GzipFile('filename', 'rb')
f.close()
----
However, this is different to the way that Python generates 
built-in file objects using the `open()` function. A more 
natural approach is probably to use the gzip module's `open()`
function thus:
[code,python]
----
import gzip
f = gzip.open('filename', 'rb')
# Do someting with f
f.close()
----
===============================

Does your modified code work with uncompressed files as well
as files compressed with both gzip and bzip2?

TIP: You will need to be able to decide if the filename argument 
represents a compressed file. One way to do this is to use string 
methods to examine the file name argument. A better (easer and 
more portable) approach is to use the `splitext ()` function from 
the `os.path` module. This takes a string as an argument returns 
a tuple who's second item is the final file extension 
(`.txt`, `.gz` or `.bzip2`).   





